[{"categories":null,"contents":"一次抓包以及http请求拦截方式的案例\n过程中使用到的工具： Fiddler、Postman、Jpexs-decompiler、NodeJS HTTP请求分析 打开fiddler，然后我们对游戏进行一次兑换操作。这样即可在fiddler左侧列表得到游戏对HTTP的请求操作 而我们所需要的便是对最后一行HTTP请求进行分析:\n1 2 3 4 5 6 7 8 9 10 11 12 13 POST http://my.4399.com/jifen/activation HTTP/1.1 Host: my.4399.com Connection: keep-alive Content-Length: 76 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36 Content-Type: application/x-www-form-urlencoded Accept: */* Origin: http://sbai.4399.com X-Requested-With: ShockwaveFlash/32.0.0.465 Referer: http://sbai.4399.com/4399swf/upload_swf/ftp14/cwb/20140214/chj/etjv1130.swf/[[DYNAMIC]]/4 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: *** 从抓到的数据中，我们可以轻松的得出这是一个使用HTTP/1.1协议的 POST 请求。 确定了请求方式以后，我们再打开PostMan模拟一次POST请求，来观察得到的数据。 对数据进行转码后我们即可得到一串JSON：\n1 {\u0026#34;code\u0026#34;:101,\u0026#34;result\u0026#34;:[],\u0026#34;msg\u0026#34;:\u0026#34;参数错误\u0026#34;} SWF逆向分析 在得到这串数据后，我们的逆向分析操作便可以开始了。对游戏进行抓包得到SWF的方法就不过多赘述，我们直接进行逆向分析。\n回想第一步操作，我们在对游戏进行兑换时，游戏进行了对话框提示，内容为 参数错误！无法兑换! 既然有了字符串，那先不管这串字符在SWF中是否被加密，先对其进行搜索。 果不其然，在搜索到的唯一一项结果中，可以很明显的判断出这就是兑换礼包的AS代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 var code0:int = JSON2.decode(data0).code; var result0:int = int(JSON2.decode(data0).result); var tipstr:String = \u0026#34;\u0026#34;; Game.testText.addTestText(\u0026#34;当前结果：\u0026#34; + result0); switch(code0) { case 99: tipstr = \u0026#34;未知错误！无法兑换！\u0026#34;; break; case 100: if(result0 == 132) { tipstr = \u0026#34;兑换成功！你获得了新手礼包！\u0026#34;; this.getGift(); } else if(result0 == 330) { tipstr = \u0026#34;兑换成功！你获得了新春礼包！\u0026#34;; this.getGift2(); } else if(result0 == 164) { tipstr = \u0026#34;兑换成功！你获得了周年礼包！\u0026#34;; this.getGift3(); } else if(result0 == 209) { tipstr = \u0026#34;兑换成功！你获得了双节礼包！\u0026#34;; this.getGift4(); } break; case 101: tipstr = \u0026#34;参数错误！无法兑换！\u0026#34;; break; case 102: tipstr = \u0026#34;兑换码不存在！无法兑换！\u0026#34;; break; case 103: tipstr = \u0026#34;兑换码还没被兑换！\u0026#34;; break; case 104: tipstr = \u0026#34;兑换码被使用过了！\u0026#34;; break; case 105: tipstr = \u0026#34;兑换码只能被领取者使用！\u0026#34;; break; case 106: tipstr = \u0026#34;该礼包已经兑换过了！\u0026#34;; break; case 107: tipstr = \u0026#34;验证码失效！无法兑换！\u0026#34;; break; case 108: tipstr = \u0026#34;兑换码失效！无法兑换！\u0026#34;; break; case 109: tipstr = \u0026#34;激活失败！无法兑换！\u0026#34;; break; case 110: tipstr = \u0026#34;您的账号今天已经使用过兑换码了，不能再使用了！\u0026#34;; } 结合之前我们POST请求得到的数据，我们不难看出，JSON数据中code的值对应着上文代码的code0变量，也就是说我们可以通过某种方法将JSON数据中的code项返回值修改为上文代码中礼包兑换成功的100这一返回值 要想实现我们这一设想，那就需要使用Fiddler配合NodeJS来操作:\nNodeJS负责搭建一个可以进行POST请求的本地服务器，通过它，我们可以模拟出兑换成功的JSON数据。 Fiddler中的自动响应这一功能，便可以通过拦截HTTP请求，将其转发到指定的链接，从而实现对客户端的欺骗。 编写本地服务器 代码仅供参考\rcode值对应上文代码中的code0变量 result值则对应着上文代码中的result0变量\n启动NodeJS服务 1 2 npm install express #安装express模块 node test.js #启动服务 服务启动完成后，我们便可以通过PostMan测试本地服务器效果了 JSON完美返回，但由于Fiddler无法识别127.0.0.1、localhost这类地址，所以我们需要修改hosts，填入任意域名，使它指向127.0.0.1或localhost 我将127.0.0.1指向了www.flowerzzz.top，那么在我这台计算机上，访问www.flowerzzz.top将会被转发到127.0.0.1 PostMan测试成功 拦截HTTP请求 在自动响应栏添加规则，写入规则，最后记得勾选顶部启动规则，自动响应图标将呈现绿色，若是灰色便是没有启动规则 最后登录游戏，兑换就可以看到效果了。\n本地服务器填写的JSON数据中，result的数字便代表了将会领取的礼包 132代表新手礼包 330代表新春礼包 164代表周年礼包 209代表双节礼包\n文章仅供学习交流 ","date":"May 10","permalink":"https://example.com/post/super3gits/","tags":null,"title":"HTTP请求拦截案例"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://example.com/about/","tags":null,"title":""},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://example.com/articles/","tags":null,"title":"所有文章"}]